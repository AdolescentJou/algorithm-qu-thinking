<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>

<body>
	<script>
		/*
		
		1.定义
    		    	方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。
		2. 为什么使用递归 ？递归的优缺点 ？
			优点：代码的表达力很强，写起来简洁。
			缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。

		3. 什么样的问题可以用递归解决呢 ？

		一个问题只要同时满足以下 3 个条件，就可以用递归来解决。

			问题的解可以分解为几个子问题的解。何为子问题 ？就是数据规模更小的问题。
			比如，前面讲的电影院的例子，你要知道，自己在哪一排的问题，可以分解为前一排的人在哪一排这样一个子问题。
			问题与子问题，除了数据规模不同，求解思路完全一样
			比如电影院那个例子，你求解自己在哪一排的思路，和前面一排人求解自己在哪一排的思路，是一模一样的。
			存在递归终止条件
			比如电影院的例子，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是 f(1) = 1，这就是递归的终止条件。

		4. 递归常见问题及解决方案

			警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。
			警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。

		5. 如何实现递归 ？

		如果一个问题 A 可以分解为若干个子问题 B、C、D，你可以假设子问题 B、C、D 已经解决。
		而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。
		屏蔽掉递归细节，这样子理解起来就简单多了。

		因此，理解递归代码，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

		6. 如何优化
		当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，
		当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。

		试着对阶乘函数分析执行的过程，我们会发现，JavaScript 会不停的创建执行上下文压入执行上下文栈，
		对于内存而言，维护这么多的执行上下文也是一笔不小的开销呐！那么，我们该如何优化呢？

		答案就是尾调用。

		尾调用，是指函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。

		比如
		function f(x){
			return g(x);
		}

		使用尾调用优化过的阶乘函数
		function factorial(n, res) {
			if (n == 1) return res;
			return factorial2(n - 1, n * res)
		}

		console.log(factorial(4, 1)) // 24

		*/
	</script>
</body>

</html>